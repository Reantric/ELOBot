import * as Discord from "discord.js";
import { IBotEvent } from "../api/eapi";
import Titles from "../util/Titles";
import { ButtonStyle, Collection } from "discord.js";
import { QuickDB } from "quick.db";
const db = new QuickDB();
var standings = db.table('rank');
var history = db.table('history');
var MLonMG = db.table('MLonMG');
// @ts-ignore
import * as glicko2 from "glicko2";
import { generateResponse } from "../util/UserEmulator/eval.js";

//var Filter = require('bad-words'); //npm install badwords
//let filter = new Filter();
var count = 0;

export default class amogML implements IBotEvent {

    name(): string {
        return "AMOG ML";
    }

    help(): string {
        return "AMOG ML";
    }       
    
    cleanup(content: string[], channelName: string, Bot: Discord.Client): string {
        return `<BOS><CHANNEL_${channelName}> ` + content.map(msg => {
            // Replace emotes: capture the name between <: and : followed by digits and >
            let cleaned = msg.replace(/<:([^:]+):\d+>/g, ':$1:');
    
            // Replace user mentions: capture the ID in <@!ID> or <@ID>
            cleaned = cleaned.replace(/<@!?(\d+)>/g, (match, userId) => {
                const user = Bot.users.cache.get(userId);
                return user ? `@${user.username}` : match;
            });
    
            return cleaned;
        }).join("\n");
    }

    /**
     * Replaces emoji tokens (e.g. :kekw:) in the text with the corresponding emoji from the guild.
     * If an emoji is not found, it leaves the text as is.
     * @param content - The string content generated by the model.
     * @param Bot - The Discord client instance to access the emoji cache.
     * @returns The processed string with tokens replaced.
     */
    cleandown(content: string, Bot: Discord.Client): string {
        // Replace emoji tokens in the form :emojiName:
        return content.replace(/:([a-zA-Z0-9_]+):/g, (match, emojiName) => {
            const emoji = Bot.emojis.cache.find(e => e.name === emojiName);
            return emoji ? emoji.toString() : match;
        });
    }
    
    
    async runEvent(msg: Discord.Message, Bot: Discord.Client): Promise<void> {
       if (msg.author.bot) return;
     //   if (msg.guild!.id != '838203182630305822') return;
      //console.log(msg.content);

        let msgList: { content: string, channel: string }[] = (await MLonMG.get(msg.author.id)) || [];
        
            
        msgList.push({content: msg.content, channel: msg.channel.id});

       // const emoji = msg.guild!.emojis.cache.find(e => e.name === "ithink");


      //  msg.reply("You have sent " + JSON.stringify(msgList) + `${emoji}`);
        
        if (msgList.length >= 4) {
            msgList.shift();
        }
        
        await MLonMG.set(msg.author.id, msgList);

        if (msgList.length > 0 && msg.author.id == '260118674306760705') {
            const allSameChannel = msgList.every(m => m.channel === msg.channel.id);
            if (allSameChannel && Math.random() < 0.01) {
                const msgChannel: Discord.Channel = Bot.channels.cache.get(msgList[0].channel) as Discord.Channel;
                if (msgChannel instanceof Discord.TextChannel){
                    console.log("Generating response...");
                    console.log(this.cleanup(msgList.map(message => message.content),msgChannel.name,Bot));
                    generateResponse(this.cleanup(msgList.map(message => message.content),msgChannel.name,Bot)).then((response) => {
                    msg.reply('*[AMOG]:* ' + this.cleandown(response,Bot));
            });
        }

                
        }

        }
    
    }
    
}


/**
 * You have sent [{"content":":kekw","channel":"1065644982213542020"},{"content":"<:ithink:1343813757331181689>","channel":"1065644982213542020"}]<:ithink:1343813757331181689>
 */